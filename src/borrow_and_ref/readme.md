声明一变量后直接&，就直接是引用，且不占用所有权.

引用没有涉及所有权问题。 

借用是暂时借掉了，占用了所有权

如果用了：
1. 通过一个指向变量的引用来访问该变量。

2. 函数返回之类


然后再看Rc，Cell这些内容，还有Box


Box是一个智能指针，它会将包含在Box中的值分配到堆上，使得这个值在所有权转移时可以被移动。通常情况下，我们会在堆上创建一个对象，然后将它放到一个Box中。在将Box传递给函数时，函数会获取这个Box的所有权并在函数执行结束时自动释放这个Box所指向的内存。因此，Box和借用有着类似的作用，都是在传递值时不会发生所有权的转移。

Rc是一个引用计数智能指针，它可以让我们在多个所有者之间共享数据。Rc内部维护了一个计数器，每当一个新的所有者被创建时，计数器就会加一。当所有者被销毁时，计数器就会减一。当计数器的值为0时，被管理的值也会被销毁。由于Rc允许多个所有者同时存在，因此它与借用的概念有些类似。

Cell是一个可变的容器类型，它允许我们在不可变引用的情况下修改值。Cell可以用来在Rc对象之间共享可变状态，也可以用来在多个线程之间共享状态。当我们需要共享可变状态时，借用并不够用，因为Rust不允许在拥有不可变引用的同时进行可变访问。而使用Cell可以绕开这个限制，让我们在不破坏借用规则的前提下共享可变状态。

## Box
作为可被交付的所有权容器
> 可以这样理解，Box 通过在堆上分配内存，将值放在堆上，然后返回一个指向堆上值的指针，使得值在堆上被分配的内存被所有权容器所持有。这个所有权容器就是 Box 对象本身，它持有对堆上值的所有权，并且在 Box 对象被销毁时自动释放内存。因此，Box 可以被看作是可被交付的所有权容器，将值包装在 Box 内可以方便地在不同的作用域之间传递所有权。

所以，Box可以让一个值的所有权给到了Box来做主

那值的所有权给到了Box来做主，后续的使用是不是要主要这个Box自身的所有权管理啊？

是的，值的所有权被转移到 Box 中，因此后续的使用需要主要 Box 的所有权管理。具体来说，通过 Box::new 创建的堆分配对象会在其所有权超出作用域时自动被释放。如果在使用完 Box 后，需要将其内部的值还原为一般的栈分配变量，可以使用 Box::into_inner 方法来获取值的所有权并释放 Box 对象。如果需要在多个地方共享值，可以使用 Rc 或 Arc 对象，这样可以允许多个所有者共享值的所有权。


## Rc  Reference Counting
Rc是一个引用计数智能指针，它可以让我们在多个所有者之间共享数据。Rc内部维护了一个计数器，每当一个新的所有者被创建时，计数器就会加一。当所有者被销毁时，计数器就会减一。当计数器的值为0时，被管理的值也会被销毁。由于Rc允许多个所有者同时存在，因此它与借用的概念有些类似。

Rc是通过多个的引用来，并加入计数功能的管理实现的。

记录有多少个 Rc 实例引用了同一个对象？ 

我这里的疑问有一个，Rc是怎么共享所有权的，不是说简单的引用就不涉及所有权的问题吗？
简单的引用确实不涉及所有权的问题，因为引用只是对已经存在的值的一个别名，不拥有其所有权。

内部实现是对共享数据的引用计数进行加1，也就是对计数器进行复制，而不会对数据本身进行克隆。


Rc是将一个值的所有权转移到了Rc对象本身，而不是那个值身上。当你将一个值包装在Rc中时，Rc对象拥有该值的所有权，而其他使用该值的Rc实例都只是持有该值的共享引用。当Rc对象的引用计数归零时，它会释放内存并销毁它所持有的值。因此，所有的Rc实例都是在共享同一个值的所有权，而该值的内存分配和释放由Rc对象来管理。

首先Rc跟之前的Box一样作为容器接代了这个值的所有权

### Arc 
使用原子计数 atomic reference counting

#### 首先理解原子操作。

原子操作通常由硬件提供支持，可以保证操作的原子性

在硬件层面上，原子操作的实现需要满足以下两个条件：

原子操作必须是不可分割的。也就是说，它们必须是连续的指令序列，在执行的过程中不能被中断。这通常是通过使用硬件锁（如总线锁或缓存锁）来实现的，保证了在执行原子操作时不会被其他线程或进程干扰。
原子操作必须是原子性的。也就是说，它们必须能够在任何情况下保持一致性，不会因为程序异常、硬件故障或其他异常情况而破坏数据的完整性。这通常是通过使用硬件级别的比较和交换指令来实现的。
在具体实现上，常见的原子操作指令包括 x86 架构下的 LOCK 指令、ARM 架构下的 LDREX/STREX 指令等。这些指令在执行时会自动加锁，保证了多个线程或进程同时访问同一块内存时的一致性和安全性。

总之，硬件级别的原子操作是保证多线程并发执行安全性的重要手段，它们能够确保操作的原子性和互斥性，避免了因并发执行带来的数据竞争、死锁和数据不一致等问题。


## Cell
Cell 是 Rust 的标准库中提供的一种原子类型，它允许在不使用锁的情况下，以原子方式读写某个变量的值。Cell 主要用于对单个变量的简单操作，比如复制和赋值操作，可以保证这些操作是原子的，不会被并发线程干扰。
Cell 是 Rust 的标准库中提供的一种原子类型，它允许在不使用锁的情况下，以原子方式读写某个变量的值。Cell 主要用于对单个变量的简单操作，比如复制和赋值操作，可以保证这些操作是原子的，不会被并发线程干扰。

Cell 的实现方式是通过在编译期进行代码优化来保证操作的原子性，而不是像 Mutex 或 RwLock 这些同步原语那样使用系统调用等机制进行加锁。这样一来，Cell 的开销要比同步原语小得多，并且不需要线程上下文切换的代价，因此能够提供更好的性能。

Cell 适用于多线程环境下需要频繁读写某个变量的情况，比如在计数器中进行加减操作，或者在状态机中改变状态。值得注意的是，由于 Cell 是一种非线程安全的原子类型，所以它只能被用于不会造成竞争条件的场景。如果需要对共享资源进行复杂的操作，需要使用 Mutex、RwLock 等同步原语来保证线程安全。


## RefCell

与 Cell 一样，RefCell 也提供了两个方法：borrow() 和 borrow_mut()。它们分别用于获取不可变借用和可变借用。与 Cell 不同的是，如果在同一时刻有多个可变借用或者有一个可变借用和不可变借用，则会导致程序崩溃。

为了解决这个问题，RefCell 采用了一种动态检查借用规则的方式。当进行借用时，会检查当前是否已经存在一个可变借用或者是否已经存在一个不可变借用和一个可变借用，如果满足这些条件，则程序会崩溃，否则就可以进行借用。

与 Cell 类似，RefCell 也是在运行时检查借用规则，因此会带来一定的性能损失。不过，如果需要在运行时动态检查借用规则的情况下，使用 RefCell 是一个非常好的选择。


## Cell 和 RefCell

Cell 


## Box 和 Rc
Box 和 Rc 作为 Rust 中的两种指针类型，它们的主要区别在于所有权的转移和共享的方式。一般来说，Box 更适合用于单一所有权的场景，即只有一个所有者的情况；而Rc 更适合用于多重所有权的场景，即有多个拥有同一个值的所有者的情况。


Box 的使用
如果一个值只有一个所有者，并且需要在函数之间传递，那么可以使用 Box 来转移所有权
```rust
fn main() {
    let value = Box::new(42);
    consume_box(value);
}

fn consume_box(value: Box<i32>) {
    println!("Box value: {}", value);
}
```

Rc 的使用
如果需要多个所有者共享同一个值，则可以使用 Rc 来共享所有权
```rust
use std::rc::Rc;

fn main() {
    let value = Rc::new(42);
    consume_rc(value.clone());
    consume_rc(value.clone());
}

fn consume_rc(value: Rc<i32>) {
    println!("Rc value: {}", value);
}
```
这个例子中，value 被放到 Rc 中以共享所有权，并且在两个函数之间传递 Rc 的克隆体以共享相同的值。注意，在调用 consume_rc 函数时，我们必须使用 clone 方法来创建 Rc 的新克隆体，以便多个函数都可以拥有相同的值的所有权。